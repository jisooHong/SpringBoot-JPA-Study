# 트랜잭션

데이터를 파일에 저장하지 않고 데이터베이스에 저장하는 이유는 무엇일까?

바로 데이터베이스는 트랜잭션이라는 개념을 제공해주기 때문이다. 

그럼 트랜잭션이란 무엇일까?

> 트랜잭션: "쪼갤 수 없는 업무 처리의 최소 단위”
> 

은행업무를 예시로 들어보자. A가 B에게 돈을 송금한다. 

과정은 이렇게 이루어질것이다. 

1. A가 B에게 5000원을 송금한다.
2. B의 계좌에 5000원이 입금된다.

만약 1의 과정은 성공했지만 2의 과정에서 오류가 나면 어떻게 될까? 

A의 계좌에서 돈은 빠져나갔지만 B의 계좌에는 입금이 되지 않을 것이다.

이렇게 은행업무는 2가지 과정이 세트로 모두 이루어져야한다.

한가지라도 에러가 발생하면 과정은 다시 그 전의 상태로 되돌아가야한다.

이것을 트랜잭션이 ‘원자성’을 가지고 있다고 이야기한다.

트랜잭션은 `ACID`원칙을 가진다.

`Automatic 원자성` : 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 성공되어야한다.

`Consistency 일관성`: 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야한다. 예를 들면 무결성조건이 같아야 한다.

`Isolation 격리성`: 동시에 실행되는 트랜잭션들은 서로에게 영향을 미치지 않아야한다. 예시로 sessionA에서 트랜잭션을 수정할 때 다른 Session들은 해당 트랜잭션을 수정하지 못해야한다. 

격리수준을 정할 수 있는데 대부분 `Read Commited` (커밋된 읽기) 를 사용한다.

보통 작업시 해당 트랜잭션에 `Lock` 을 걸어준다. commit이 완료되면 `Lock`은 자동으로 반납된다.

`Duration 지속성`: 트랜잭션을 성공적으로 끝내면 (commit 될 시) 항시 기록을 남겨야한다. 

---

트랜잭션은 성공 시 `Commit`, 실패 시 `Rolllback`을 호출한다.

기본적으로 데이터베이스는 `AutoCommit = True`로 설정이 되어있다.

`autocommit`은 한줄이 끝나면 자동으로 커밋이 이루어진다 

```sql
update member set money=10000 - 2000 where member_id = 'memberA'; //성공
update member set money=10000 + 2000 where member_iddd = 'memberB'; //쿼리 예외
```

 → 이 경우 두번째 줄은 오류가 난다. `autocommit = True` 일 경우 A의 돈만 줄어드는 심각한 문제가 발생한다. 따라서 트랜잭션이 필요하다. 

```sql
set autocommit true; //트랜잭션 시작
update member set money=10000 - 2000 where member_id = 'memberA'; //성공
update member set money=10000 + 2000 where member_iddd = 'memberB'; //쿼리 예외
```

`set autocommit true`는 트랜잭션을 시작을 의미한다.

두번째 쿼리는 오류가 났기 때문에 첫번째 쿼리도 취소시켜야한다. 이 때 `rollback`을 실행시켜준다.

다음에는 트랜잭션을 실제 어플리케이션에 적용한 예제를 작성할 예정이다
