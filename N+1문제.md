## N+1문제
 연관관계 시, 한개의 쿼리만 예상했지만 N개의 쿼리가 추가로 발생하는 문제
 Join이 바로 걸리지 않아서 생기는 문제

---------------------------------------------------------------------------------------------------
```Eager``` ```즉시로딩```은 모든 ```N+1```문제를 발생시킨다.   

![image](https://user-images.githubusercontent.com/46811084/161742857-ada9ab75-12b5-41ee-9489-d4f45b2e4456.png)   
멤버(N) - 팀(1) 관계   

```findAll```로 모든 팀만 조회하고 싶다.   
이 때, ```즉시로딩```을 사용하면 관련된 멤버들의 쿼리문도 팀을 조회한 후 전부 조회된다.
 
그렇다면 ```지연로딩```을 사용하면 ```N+1```문제가 해결될까?   
정답은 X , 처음에만 조회되지 않는 것이지 나중에 필드 검색을 할 때 연관된 쿼리문이 나타난다. 

--------------------------------------------------------------------------------------------------- 
즉 N+1문제가 생기는 이유는 
JPA가 자동으로 먼저 생성해주는 ```Jpql```을 통해서 우선적으로 쿼리를 만들다보니 연관관계가 걸려있어도 ```join```이 바로 걸리지 않는다.

```jpql```의 ```fetch join```으로 해결 가능   

그러나 ```페이징``` 할 때는 ```fetch join```을 해도  ```limit```가 작용하지 않고 인메모리로 모든 값이 조회된다..   
-> 이 때는 Batch Size를 설정해줘서 해결
